django:
MTV
django-admin.py startproject xxx  创建project
python manage.py startapp xxx     创建app
python manage.py makemigrations
python manage.py migrate          //创建后台表，默认存放到sqlite里面
python manage.py createsuperuser  //创建后台账号
python manage.py runserver        //启动服务，默认8000端口

母版：只继承一个，在母版预留位置,在子版填充
在子版导入其他html页面或某一块的功能，使用include
{% include 'xxx.html' %}
母版(basic.html):
<!DOCTYPE html>
<html>
<head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
        <title>{% block title %}{% endblock %}</title>
		{% block css %}{% endblock %}   //此处子版单独设置自己的css
        <style>
                body {
                        margin:0;
                        padding:0;
                }
                .pg-header {
                        height:48px;
                        background-color:blue;
                }
                .pg-body .menu {
                        width:200px;
                        background-color:#ddd;
                        position:absolute;
                        top:48px;
                        left:0;
                        bottom:0;
                        overflow:auto;
                }
                .pg-body .content {
                        background-color:grey;
                        position:absolute;
                        top:48px;
                        right:0;
                        left:200px;
                        bottom:0;
                        overflow:auto;
                }
        </style>
</head>
<body>
        <div class='pg-header'>header</div>
        <div class='pg-body'>
                <div class='menu'>menu</div>
                <div class='content'>
                        {% block content %}{% endblock %}
                </div>
        </div>
		{% block js %}{% endblock %}   //此处子版单独设置自己的js
</body>
</html>
子版(index.html):
% extends "basic.html" %}   //继承母版
{% block content %}
欢迎你,尊敬的用户{{name}}
{% include "xx.html" %}  //导入其他的HTML页面
{% endblock %}
{% block title %}Test{% endblock %}
{% block css %}
	<style>
		.menu {
			color:red;
		}
	</style>
{% endblock %}
1，在app下面创建static目录(包括css,imgs,js和plugins)用于存放静态文件
<link rel='stylesheet' href='../static/css/common.css' />
<link rel='stylesheet' href='../static/css/style.css' />

2，当static目录放在project目录下时，需要在settings.py里面如下设置才能加载到css
那么此时的css的路径配置为
<link rel='stylesheet' href='/static/css/common.css' />
<link rel='stylesheet' href='/static/css/style.css' />
STATIC_URL = '/static/'
STATICFILES_DIRS=(
    os.path.join(BASE_DIR,'static'),
)

3,路由系统
默认处理函数,动态url,分级匹配
from app01 import views
urlpatterns=[
	//url(r'^$',views.index),  //一行行匹配，匹配到了就不在往下执行了
	url(r'^index/(\d+)$',views.index),  //传过去一个参数nid，用在分页
	url(r'^index/(\d+)/(\d+)$',views.index),  //传过去两个参数到后边函数
	url(r'^index/(?P<id>\d+)$',views.index),   //传过去一个参数id
	url(r'^index/(?P<id>\d+)/(?P<name>\w+)',views.index),  //传过去两个参数id和name
]
views.py:
def index(request,nid):
	return nid
多个app时，url放在各个app下，做一个映射
project下的urls.py:
url(r'^app01/',include('app01.urls')),

app01下的urls.py:
from app01 import views
url(r'^index/',views.index),
正则表达式:
\d:数字
\D:非数字
\s:空白字符
\S:非空白字符
\w:单词字符[A-Za-z0-9_]
\W:非单词字符
*:0或无限次
+:1或无限次
?:0或1次
*? +? ?? {m,n}?:非贪婪模式
|:代表坐标表达式匹配任意一个，先匹配左边，一旦成功则跳过右边,如果|
   没有被包括在()中，则它的范围是整个表达式(千万注意)

反射实现动态路由:
通过反射找到对应的函数,不推荐

中间件(类)
对web请求处理需要中间件
settings.py的MIDDLEWARE_CLASSES控制中间件
csrf:在第一次返回的数据时为浏览器加一段字符串，在第二次请求的时候
就会带上这个字符串，如果字符串匹配合格pass，否则forbidden
请求进来后会挨个执行MIDDLEWARE_CLASSES里面注册的中间件的process_view函数
然后执行路由系统匹配到的方法,出去的时候会倒序执行注册的中间件里面的process_response函数
MIDDLEWARE_CLASSES = (
    'django.contrib.sessions.middleware.SessionMiddleware',
	        ↓process_view							↑
    'django.middleware.common.CommonMiddleware',
			↓							↑
    'django.middleware.csrf.CsrfViewMiddleware',
			↓							↑
    'django.contrib.auth.middleware.AuthenticationMiddleware',
			↓							↑
    'django.contrib.auth.middleware.SessionAuthenticationMiddleware',
			↓							↑
    'django.contrib.messages.middleware.MessageMiddleware',
			↓							↑
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
			↓							↑
    'django.middleware.security.SecurityMiddleware',
			↓							↑
	'middleware.middle1.m1',
						 ↑  process_response
)
自定义一个中间件:
***不管怎么样,process_response是一定要执行的不论是process_request有返回值还是views.py里面出错返回给
process_exception，都要走process_response(另外无论是request还是exception只要遇到return有返回值,直接跳到response)
在mysite下面新建一个middleware的文件夹里面创建一个中间件middle1.py
class m1(object):
	
	//这两个函数必须都得写上，参数也不能变
	def process_request(self,request):
		print "m1.process_request"    
		return HttpResponse('Hello')   //这里也可以加返回值,执行流程就变了，他会直接到最后的process_response,
		//然后一层层传递返回给用户（返回的过程一定要执行一遍）
		
	def process_view(self,request,callback,callback_args,callback_kwargs):
		print 'm1.process_view'

	def process_response(self,request,response):   //response views里面的返回值
		print 'm1.process_response'
		return response								//必须要有返回值
	
	def process_exception(self,request,exception):  //当views.py里面的程序报错时执行，执行时从最后一个
		pass										//process_exception开始到第一个，然后再到最后一个response,走一遍response,然后返回给用户
		
//最多定义中间件的四个方法:process_view,process_response,process_exception,process_request
在请求过程中可以看到当请求进来的时候,先执行了m1.process_view,出去的时候又执行了m1.process_response
即使有多个中间件，也是这个顺序先执行request和view,然后执行views.py里面对应的函数，最后出去的时候执行response
执行过程:
*************************************************
先生成多个空列表
process_request_list=[]
process_view_list=[]
process_response_list=[]
然后循环注册的类
将每个类的方法分别加到对应的列表里
当用户请求过来时，先for循环process_request_list和process_view_list列表
接着执行views.py里面的函数
最后在循环process_response_list列表里面的方法
**************************************************
middleware/middle1.py:

from django.shortcuts import HttpResponse

class m1(object):

	def process_request(self,request):
		#return HttpResponse('cash')
		print "m1.process_request"

	def process_view(self,request,callback,callback_args,callback_kwargs):
		print 'm1.process_view'

	def process_response(self,request,response):
		print 'm1.process_response'
		return response

	def process_exception(self,request,exception):
		print "bbbb"
		return HttpResponse('eeeee')

middleware/middle2.py:
from django.shortcuts import HttpResponse

class m2(object):
	def process_request(self,request):
			#return HttpResponse('Hello')
			print "m2.process_request"

	def process_view(self,request,callback,callback_args,callback_kwargs):
			print 'm2.process_view'

	def process_response(self,request,response):
			print 'm2.process_response'
			return response

	def process_exception(self,request,response):
			print 'aaaa'		

views.py:
def index(request):
	raise Exception('bbb')  //异常报错,返回eeeee
	return HttpResponse('ok')
返回:
m1.process_request
m2.process_request
m1.process_view
m2.process_view
aaaa
bbbb
m2.process_response
m1.process_response
//顺序是先分别执行process_request,再分别执行process_view,然后到views.py里面的函数
，这里面的函数发生异常,先到m2的exception,没有返回值，再到m1的exception,有返回值则直接返回该返回值
给m2的response，再到m1的response,最后返回给用户
	
//如果刚进来时m1里面request就有返回值,就不会再到m2的request,直接到m2的response,再到m1的response,最后返回给用户
注册顺序:
'middleware.middle1.m1',
'middleware.middle2.m2',

缓存:文件，内存和数据库

cookie和session,session是个字典
cookie保存于本机,session保存于服务器
当用户登录时，会在服务器上生成一段字符串，发回到客户机，保存到客户机上，服务器
会把这段字符串保存到数据库里并对应若干key/value(加密)值
客户端需要把这段字符串发送到服务端时才能获取这些key/value值
django默认session放在数据库里，可以配置放在内存里
数据库里django_session里第一个字段(session_key)是本机保存的session_id的值
第二个字段(session_data)为所有保存的key/value加密后的值
清除session:del request.session['xxx']

form表单:
#coding:utf8
from django.shortcuts import render,HttpResponse,render_to_response
from django import forms
from django.core.exceptions import ValidationError
import re
# Create your views here.

#自定义检测机制,然后加到validators列表里,还要渲染到相应的HTML标签
def mobile_validate(value):
    mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$')
    if not mobile_re.match(value):
                raise forms.ValidationError('手机号码格式错误')

def ip_validate(value):
	ip_re=re.compile(r'^([1-9][0-9]|[12][0-5][0-4])\.([1-9][0-9]|[12][0-5][0-4])\.([1-9][0-9]|[12][0-5][0-4])\.([1-9][0-9]|[12][0-5][0-4])$')
	if not ip_re.match(value):
			raise forms.ValidationError('IP格式错误')

def url_validate(value):
	url_re=re.compile(r'^http:\/\/([\w+]\.){1,}(com|cn|net|cc|org|)$')
	if not url_re.match(value):
		raise forms.ValidationError('URL格式错误')
		
sex_choice=(
	(0,u'男'),
	(1,u'女'),
)

class UserInfo(forms.Form):
	username=forms.CharField()
	passwd=forms.CharField(min_length=10,max_length=20,error_messages={'min_length':u'长度不能小于10','max_length':u'长度不能大于20'},widget=forms.PasswordInput(attrs={'class':'form-control','placeholder':u'密码'}))
	email=forms.EmailField()
	IP=forms.CharField(validators=[ip_validate])
	birthday=forms.DateField(error_messages={'invalid':u'日期格式不正确'},widget=forms.DateInput())   #不能设置属性
	moible=forms.CharField(validators=[mobile_validate],widget=forms.TextInput(attrs={'class': "form-control",'placeholder': u'手机号码'}))
	sex=forms.IntegerField(widget=forms.widgets.Select(choices=sex_choice,attrs={'class':'form-control'}))   #下拉框
	url=forms.URLField(validators=[url_validate],widget=forms.URLInput(attrs={'class':'form-control','placeholder':u'个人网址'}))
	description=forms.CharField(required=False,max_length=256,widget=forms.widgets.Textarea(attrs={'class':'form-control','placeholder':u'详细描述','rows':15}))

def login(request):
	obj=UserInfo()
	if request.method == "POST":
			#将提交过来的数据封装到UserInfo对象里
			user_list=UserInfo(request.POST)
			#验证提交的数据
			if user_list.is_valid():
					data=user_list.clean()
					#返回字典,要拿到单个form表单里面的值,data['username']
					print data
			else:
					error_msg=user_list.errors
					return render_to_response('login.html',{'obj':obj,"error_msg":error_msg})
	return render_to_response('login.html',{'obj':obj})

login.html:
<form action="/app03/login/" method="post">
        <p>用户名 {{obj.username}}</p>
        <p>密码 {{obj.passwd}}<span>{{error_msg.passwd}}</span></p>   #显示错误
        <p>邮箱 {{obj.email}}</p>
        <p>生日 {{obj.birthday}}<span>{{error_msg.birthday}}</span></p>
        <p>IP {{obj.IP}}<span>{{error_msg.IP}}</span></p>
        <p>手机 {{obj.moible}}<span>{{error_msg.moible}}</span></p>
        <p>性别 {{obj.sex}}</p>
		<p>个人网站 {{obj.url}}{{error_msg.url}}</p>
        <p>描述 {{obj.description}}</p>
        <p><input type="submit" value="提交" /></p>
<form>
form表单字段类型:默认的required=True
BooleanField
CharField
DateField:2016-09-07
DateTimeField:2016-09-07 11:00:00
FileField
IntegerField
URLField

去掉HTML页面报错前面的.,需要用到simple_tag
此处修改为error_msg=user_list.errors.as_data()(默认的是as_url())
格式是{'subject': [ValidationError(['This field is required.'])]},要获取的数据是error_msg[0][0]
在app下面的templatetags目录下面的tags.py里面定义一个函数:
@register.simple_tag
def error_message(arg):
if arg:
		return arg[0][0]
else:
		return ''
		
HTML中修改如下
{% load tag %}
<body>
<form action="/app03/login/" method="post">
	<p>用户名 {{obj.username}}</p>
	<p>密码 {{obj.passwd}}<span>{% error_message error_msg.passwd %}</span></p>
	<p>邮箱 {{obj.email}}</p>
	<p>生日 {{obj.birthday}}<span>{% error_message error_msg.birthday %}</span></p>
	<p>IP {{obj.IP}}<span>{{error_msg.IP}}</span></p>
	<p>手机 {{obj.moible}}<span>{% error_message error_msg.moible %}</span></p>
	<p>性别 {{obj.sex}}</p>
	<p>个人网站 {{obj.url}}{% error_message error_msg.url %}</p>
	<p>描述 {{obj.description}}</p>
	<p><input type="submit" value="提交" /></p>
<form>
</body>
ajax提交复杂数据(字典和数组):
<input type="button" value="提交" onclick="ajaxSubmit()" />
<script src="../static/js/jquery-1.10.1.js"></script>
<script>
function ajaxSubmit(){
	var json_data={
		'name':'cash',
		'age':28,
		'address':'shanghai',
		'phone':'123456',
	};
	$.ajax({
		'type':'POST',
		'url':'/ajax_data/',
		tradition:true,                         //阻止深度序列化,使用传统的方式序列化
		data:{data:JSON.stringify(json_data)},  //将要提交的数据序列化成字符串
		success:function(res){
				var res=$.parseJSON(res)       //将接收到的数据转化成json格式
				if (res.status){
						alert(res.error_msg);
				} else {
						alert(res.error_msg);
				}       
		},
	})      
}
</script>
views.py:
def ajax_data(req):
if req.method == 'POST':
		ret={'status':True,'error_msg':''}
		if req.POST:
			print req.POST.get('data')
			ret['status']=True
			ret['error_msg']='成功'
		else:
			ret['status']=False
			ret['error_msg']='失败'
		return HttpResponse(json.dumps(ret))   //转化成json格式
else:
		return render_to_response('login.html')
		
从数据库里删除表之后这样恢复,python manage.py migrate appname
分类：
app下面删掉views.py文件创建views目录，为不同的函数进行分类(比如account.py负责登陆登出)
templates下面创建对应的目录(account目录/login.html)
外面的urls.py  url(r'^',include('app01.urls'))
from app01.views import account
app下面的urls  url(r'^login/',login)

form表单也创建一个目录forms,下面创建登录的form:account.py
forms/account.py:
from django import forms

class LoginForm(forms.Form):
        username=forms.CharField(max_length=20,min_length=10)
        password=forms.CharField(widget=forms.PasswordInput())
		
templates/account/login.html:		
<form action='/login/' method='post'>
	<p>{{obj.username}}</p>
	<p>{{obj.password}}</p>
	<p><input type='submit' value='submit' /></p>
</form>

views/account.py:
from django.shortcuts import render_to_response
from app04.forms import account as AccountForm

def login(request):
		#这样可以让用户在输错的情况下,输入框仍然保持有用户的用户名
        obj=AccountForm.LoginForm(request.POST)
        if request.method == 'POST':
                return render_to_response('account/login.html',{'obj':obj})
        else:
                return render_to_response('account/login.html',{'obj':obj})
================================================================				
静态文件引用
{% load staticfiles %}   使用这种方式可以有效的加载静态文件
<html>
<head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
        <title>登录</title>
        <link rel="stylesheet" href="{% static 'css/bootstrap.min.css' %}">
        <script src="{% static 'js/jquery-1.10.1.js' %}"></script>
        <script src="/static/js/bootstrap.min.js"></script>
        <style>
        </style>
</head>
<body>
        <h1>首页</h1>
</body>
</html>

settings.py文件配置
STATIC_URL = '/static/'
STATICFILES_DIRS=(
        os.path.join(BASE_DIR,'static'),
)

##############################################################
error_msg=obj.errors.as_json()
as_json用于ajax表单的提交，返回的是个字符串

error_msg=obj.errors
这种适用于form表单提交，需要使用simple_tags来返回第一个数据
from django import template
from django.utils.safestring import mark_safe
  
register = template.Library()

@register.simple_tag
def error_message(arg):
	if arg:
			return arg[0]    #第一个数据
	else:
			return ''
在模板文件中使用{% load tags %}加载
使用:{% error_message error_msg.username %}
	 {% error_message error_msg.password %}
#################################################################
页面刷新:window.location.href=window.location.href
#################################################################
form生成select标签,当在select标签里面增加数据时,只有重启服务才会在页面看到
因为在刷新时实例化form,只会执行init方法,所以加一个init方法
在定义form表单时加一个init方法
例如:
from django import forms
import json

class LoginForm(forms.Form):
	username=forms.CharField(max_length=20,min_length=10)
	password=forms.CharField(widget=forms.PasswordInput())
	role=forms.IntegerField(widget=forms.Select())
	def __init__(self,*args,**kwargs):  #定义init方法，刷新时，实例化form时会执行，可以看到实时添加的数据
			super(LoginForm,self).__init__(*args,**kwargs)
			fh=open('./db_role.txt')       #注意此处建立的文件,默认目录是project下面
			role_list=json.loads(fh.read())
			self.fields['role'].widget.choices=role_list
总结目前所有目录结构如下:
app04
├── admin.py
├── admin.pyc
├── apps.py
├── forms
│   ├── account.py
│   ├── account.pyc
│   ├── __init__.py
│   └── __init__.pyc
├── __init__.py
├── __init__.pyc
├── migrations
│   ├── __init__.py
│   └── __init__.pyc
├── models.py
├── models.pyc
├── templates
│   └── account
│       └── login.html
├── templatetags
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── tags.py
│   └── tags.pyc
├── tests.py
├── urls.py
├── urls.pyc
└── views
    ├── account.py
    ├── account.pyc
    ├── __init__.py
    └── __init__.pyc
models中把对象显示为字符串
def __unicode__(self):
	return self.name
	
mdels字段:
CharField:字符串字段,必须设置max_length参数
BooleanField:布尔类型,不能为空,Blank=True
DateTimeField
DateField:日期类型,auto_now=True每次改变都会更新这个时间
                   auto_now_add只是第一次创建时添加,之后的更新不再改变
DecimalField(max_digits=5,decimal_places=2)十进制小数类型
必须指定max_digits:最大位数，包括整数和小数,decimal_places小数位
EmailField
  null=True     数据库时可以为空
  unique=True   值唯一 
  blank=True    admin后台管理时可以为空
  default='xxx' 设置默认值
FloatField      浮点型
IntegerField    整型
BigIntegerField 长整型
GenericIPAddressField 字符串类型(ipv4和ipv6可选)
  protocol 默认both,ipv4和ipv6都支持
TextField
URLField
BinaryField
TimeField   HH:mm:ss
ImageField  保存的是图片的路径,参数upload_to="upload"   upload目录会自己创建
FilePathField

admin后台:
from __future__ import unicode_literals

from django.db import models

# Create your models here.
department_list=(('yw',u'运维部'),('cs',u'测试部'))

class UserInfo(models.Model):
        username=models.CharField(max_length=20)
        age=models.IntegerField()
        Email=models.EmailField(blank=True,default='123@vip.qq.com')
        URL=models.URLField(blank=True)
        IP=models.GenericIPAddressField()
        department=models.CharField(max_length=5,choices=department_list,default='yw')  #需要设置默认值
        salary=models.DecimalField(max_digits=10,decimal_places=2)   #max_digits代表的是最大位数，包括整数和小数
        mtime=models.DateTimeField(auto_now=True)				   #修改时间,会改变
        ctime=models.DateTimeField(auto_now_add=True)              #创建时间,不会改变
        headImg=models.ImageField(upload_to="upload",default='')   #需要设置默认值
        description=models.TextField(blank=True)

        def __unicode__(self):
                return self.username+" "+str(self.age)+" "+str(self.ctime)  #这里在admin后台页面展现的必须都是字符串格式的
python manage.py makemigrations app04
python manage.py migrate app04

上传文件:
% load staticfiles %}
<html>
<head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
        <title>上传文件</title>
        <link rel="stylesheet" href="{% static "/css/bootstrap.min.css" %}">
        <style>
        </style>
</head>
<body>
        <form action='/upload/' method='post' enctype="multipart/form-data">
                <p><input type='file' name='file1' /></p>
                <p><input type='submit' value='submit' /></p>
        </form>
        <script src="{% static "/js/jquery-1.10.1.js" %}"></script>
        <script src="{% static "/js/bootstrap.min.js" %}"></script>
</body>
</html>

from django.shortcuts import render_to_response

def upload(request):
	if request.method == 'POST':
			file1_obj=request.FILES.get('file1') #用FILES获取name为file1的对象
			file1_name=file1_obj.name			 #获取上传文件的名称
			print file1_obj.size                 #上传文件大小
			f=open('upload/'+file1_name,'wb')
			for line in file1_obj.chunks():      #生成器,分片上传,默认64K每次
					f.write(line)
			f.close()
	return render_to_response('upload/upload.html')
	
#一对多
class IDC(models.Model):
        name=models.CharField(max_length=20)

class host(models.Model):
        hostname=models.CharField(max_length=15)
        idc=models.ForeignKey('IDC')     #默认对应主键,要关联其他字段to_fields='',创建了另外一个字段idc_id
		
#多对多
from django.db import models

class UserGroup(models.Model):
    group_name=models.CharField(max_length=20)

class User(models.Model):
	user=models.CharField(max_length=20)
	email=models.EmailField()
	mobile=models.CharField(max_length=20)
	user_user_group=models.ManyToManyField(UserGroup)	#多对多，会创建第三张表
会创建三张表:
| app05_user                 |
| app05_user_user_user_group |
| app05_usergroup            |
desc app05_user_user_user_group;
+--------------+---------+------+-----+---------+----------------+
| Field        | Type    | Null | Key | Default | Extra          |
+--------------+---------+------+-----+---------+----------------+
| id           | int(11) | NO   | PRI | NULL    | auto_increment |
| user_id      | int(11) | NO   | MUL | NULL    |                |
| usergroup_id | int(11) | NO   | MUL | NULL    |                |
+--------------+---------+------+-----+---------+----------------+	
第三张表把User和UserGroup给关联起来

OneToOneField在一对多的基础上加了个不能重复
操作表,可以传一个字典进去:
1,增
models.tb1.objects.create(c1='aa',c2='bb');
d={'c1':'aa','c2':'bb'}
models.tb1.objects.create(**d);
m=models.tb1(c1='aa',c2='bb')
m.save()

2,查
models.tb1.objects.get(c1='aaa')   #获取单条数据
                   all()/filter(**d)
				   all().first()   #获取第一条数据
ret=models.tb1.objects.all().values('username')		    #取username那一列,[{'username':'cash'},....]
models.tb1.objects.all()  //QuerySet类型
ret=models.tb1.objects.all().values_list('username')	#获取的是只有值的元组[('cash',),.....]
ret=models.tb1.objects.all().values_list('id','username')	#获取的是id和username的元组值组成的列表[(1,'cash',),.....]
这个可以用于下拉框
self.fields['xxx'].widget.choices=models.tb1.objects.all().values_list('id','username')   	   
3,删
filter(**d).delete()

4,改
update(**d)
obj=models.tb.objects.get(id=1)
obj.c1='111'
obj.save()

进阶操作(双下划线)
models.tb1.objects.filter(name='cash').count()   #获取个数

大于小于
models.tb1.objects.filter(id__gt=1)   #大于1
models.tb1.objects.filter(id__lt=10)  #小于10
models.tb1.objects.filter(id__lt=10,id__gt=1)   #大于1，小于10

in和exclude(非)
models.tb1.objects.filter(id__in=[1,2,3])       #获取id等于1,2,3的数据
models.tb1.objects.exclude(id__in=[1,2,3])		#获取id不等于1,2,3的数据

contains,icontains大小写不敏感
models.tb1.objects.filter(name__contains='cash')
models.tb1.objects.filter(name__icontains='cash')
models.tb1.objects.exclude(name__contains='cash')

range==between and
models.tb1.objects.filter(id__range=[1,2])

startswith,istartswith,endswith,iendswith同上

order by
models.tb1.objects.filter(name='cash').order_by('id')   #asc
models.tb1.objects.filter(name='cash').order_by('-id')  #desc

group by
from django.db.models import Count,Min,Max,Sum
models.tb1.objects.filter(name='cash').values('id').annotate(c=Count('num'))
#按id进行分组,并统计数量，依次是最小，最大和总和

user_info_obj = models.UserInfo.objects.filter(id=1).values('email', 'userprofile__username').first()
print user_info_obj.keys()
print user_info_obj.values()

一对多foreignkey,两种方式向表里插入数据
1,对象形式:
all_data=obj.clean()
group_obj=models.xx.objects.get(id=xx)
models.xx.objects.create(xx=all_data[xx],xx=group_obj)
或
models.xx.objects.create(xx=all_data[xx],xx_id=all_data[xx])
也可以在form里面直接在外键的字段后面加上_id，那么就可以
models.xx.objects.create(**all_data)
外键对应的是一个对象
user_list.user_group.group_name   #获取组
user_group是一个对象，可以取id，可以取另外一张表上面对应的group_name
#####################################
class UserGroup(models.Model):
	group_name=models.CharField(max_length=20)
	
class User(forms.Form):
	username=models.CharField(max_length=20)
	user_group=models.ForeignKey("UserGroup")
#####################################
根据username进行查询:
val=request.GET.get('username')
user_list=models.User.objects.filter(username=val)

根据user_group查询属于什么组的用户
val=request.GET.get('user_group')
user_list=models.User.objects.filter(user_group__group_name=val)
#这里要用双下划线
在页面展示的时候用"."
user_list.user_group.group_name
***查询用"__",获取用"."
有第三张表关联UserGroup时,继续双下划线
class A(models.Model):
	name=models.CharField(max_length=20)
	
class UserGroup(models.Model):
	group_name=models.CharField(max_length=20)
	aa=models.ForeignKey('A')
	
class User(models.Model):
	username=models.CharField(max_length=20)
	user_group=models.ForeignKey("UserGroup")
***user_group__aa__name
双下划线继续适用于一对一

利用装饰器判断是否登录
def check_login():
        def decorator(func):
                def wrapper(request):
					username=request.session.get('username','')
					if username:
							return func(request)
					else:
							return redirect('/hm/login/')
                return wrapper
        return decorator

@check_login()
def xxx(request):
	pass
	
利用url传递中文参数需要转化编码
import urllib,sys
message=urllib.quote('添加成功'.decode(sys.stdin.encoding).encode('utf8'))
return redirect('/hm/index?message=%s' % message)

index:
message=urllib.unquote(message)
return render_to_response('index/index.html',{'message':message})
要想以弹出框的形式展示message的内容,可以在index的页面里准备一个:
.hide {
	visibility:hidden;
}
<span class='hide'>{{message}}</span>隐藏但是内容还在那
只要发现有内容,alert弹出
if($('.hide').text().length!=0){
	alert($('.hide').text());
}

过滤是否含有中文:
import re
str='xxx'
m=re.compile(u'[\u4e00-\u9fa5]+')
if m.search(str):
	print '有中文'
else:
	print '没中文'
	
from django import forms
from HM import models

class AddHostGroupForm(forms.Form):
        group_name=forms.CharField(max_length=15)

class AddHostForm(forms.Form):
	hostname=forms.CharField(max_length=15)
	host_group=forms.IntegerField(widget=forms.Select())

	def __init__(self,*args,**kwargs):
		super(AddHostForm,self).__init__(*args,**kwargs)
		self.fields['host_group'].widget.choices=models.HostGroup.objects.all().values_list('id','group_name')
		
配置动态URL
name为别名
urlpatterns = [
    url(r'^admin/', include(admin.site.urls)),
    url(r'^$',views.index,name='index'),
    url(r'^category/(\d+)',views.category,name='category'),
]
那么前面页面就可以这样配置:
<ul class="nav navbar-nav">
  <li><a href="{% url 'index' %}">综合</a></li>
  <li><a href="{% url 'category' 4 %}">北京</a></li>
  <li><a href="{% url 'category' 3 %}">上海</a></li>
</ul>

传递url到前端页面
后端需要以render的方式返回
def category(request,id):
	content=models.Article.objects.filter(categroy_id=id)
	return render(request,'index.html',{'content':content})

前端获取url:
{{request.path}}
也可以将这个参数传递到js中,需要加''
<script>
	$(function(){
		$('#navbar').find("a[href='{{ request.path }}']").each(function(){
				$(this).parent().addClass('active');
				$(this).parent().siblings().removeClass('active');
		})
	})
	alert('{{message}}');
</script>

静态文件路径问题:
STATIC_URL = '/static/'
STATICFILES_DIRS=(
        os.path.join(BASE_DIR,'static'),
		'/tmp',
		'/opt/statics',
)
这里django会到STATICFILES_DIRS定义的目录里寻找js,css等静态文件,直到找到为止
在前端页面中只需要这样配置:
<link href="/static/css/bootstrap.min.css" rel="stylesheet">
<script src="/static/js/jquery-1.10.1.js"></script>
<script src="/static/js/bootstrap.min.js"></script>

admin里配置显示:
from django.contrib import admin
from bbs import models

class ArticleAdmin(admin.ModelAdmin):
        list_display=('title','categroy_id','author_id','publish_date')
        list_filter=('publish_date',)  //按照日期来过滤
        search_fields=('title',)  //按照title来查询,必须是tuple

admin.site.register(models.Article,ArticleAdmin)
admin.site.register(models.Comment)
admin.site.register(models.ThumbUp)
admin.site.register(models.Category)
admin.site.register(models.UserProfile)
admin.site.register(models.UserGroup)

######################################################################

反向查找:
class Article(models.Model):
	'''
	帖子表
	'''
	title=models.CharField(u'文章标题',max_length=255,unique=True)
	categroy=models.ForeignKey('Category',verbose_name=u'板块')
	head_img=models.ImageField(upload_to="uploads")
	summary=models.CharField(max_length=255)
	content=models.TextField(u'内容')
	author=models.ForeignKey('UserProfile')
	publish_date=models.DateTimeField(auto_now=True)
	hidden=models.BooleanField(default=True)
	priority=models.IntegerField(u'优先级',default=1000)

	def __unicode__(self):
			return "%s author:%s" % (self.title,self.author)
			
class ThumbUp(models.Model):
	'''
	点赞
	'''
	article=models.ForeignKey('Article')
	user=models.ForeignKey('UserProfile')
	date=models.DateTimeField(auto_now=True)

	def __unicode__(self):
			return "user:%s" % self.user

class Comment(models.Model):
	'''
	评论
	'''
	article=models.ForeignKey('Article')
	user=models.ForeignKey('UserProfile')
	#自关联
	#相当于parent_comment=models.ForeignKey('comment')
	parent_comment=models.ForeignKey('self',related_name='p_comment',blank=True,null=True)
	comment=models.TextField(max_length=1000)
	date=models.DateTimeField(auto_now=True)

	def __unicode__(self):
			return "%s user:%s" % (self.comment,self.user)
如上想通过Article表找到某一篇帖子的点赞数，因为在ThumbUp表中已经有了article对应Article
的外键，所以需要通过反向查找
{% for item in author %}
	<p>{{item.comment_set.select_related.count}}</p>  #反向查找帖子的评论数
	<p>{{item.thumbup_set.select_related.count}}</p>  #反向查找该帖子的点赞数
{% endfor %}
**{{}}中不适用括号
#######################################################################################

get与filter的不同:
filter没过滤到的话不会报错，就只是空
get会报错,可以导入django自带的异常:from django.core.exceptions import ObjectDoesNotExist
def article(request,article_id):
try:
		article=models.Article.objects.get(id=article_id)
except ObjectDoesNotExist as e:
		return render(request,'404.html',{'err_msg':u'文章不存在'})
return render(request,'article.html',{'article':article})
如果是get的话，那么article.html要这么写:
<div>
		<h3>{{article.title}}</h3>
		<p>{{article.content}}</p>
</div>
如果是filter的话，需要这样写:
{% for item in article reversed %}  #这样是倒序排列，也就是最新的放到最上边
	<h3>{{item.title}}</h3>
	<p>{{item.content}}</p>
{% endfor %}
#####################################################################
模板的继承:
母版base.html:
<body>
	<div class="container">
		{% block page-container %}   #哪里需要重写写到哪里
		内容xxxxxxxxxx
		{% endblock %}
	</div>
</body>
子模板继承:
<body>
{% extends 'base.html' %}
{% block page-container %}
	内容xxxxxx
{% endblock %}
</body>
#####################################################################
CSRF:跨站域请求伪造
只有post请求才会带验证码
在form表单后面加一个{% csrf_token %},每次post数据时会带一个字符串和中间件里面的csrf进行
验证，验证通过才把post请求传到后端
<form method='post' action="{% url 'login' %}">{% csrf_token %}
views中要使用render方法才可以，不然还会报错

登陆验证:
django自带login和authenticate
from django.contrib.auth import authenticate,login,logout
def acc_login(request):   #注意不要取login这个名字
	err_msg=''
	if request.method == 'POST':
		username=request.POST.get('username')
		password=request.POST.get('password')
		user=authenticate(username=username,password=password)  #利用django自带的user库进行验证,使用登录admin后台的那套账号进行登录
		if user is not None:
				login(request,user)  #验证通过则用login方法生成session
				return redirect('/')
		else:
				err_msg=u"用户名或密码错误"
	return render(request,'login.html',{'err_msg':err_msg})
if('{{ err_msg }}'){
	alert('{{ err_msg }}');
}	
def acc_logout(request):
	logout(request)   #使用logout方法删除session
	return redirect('/')
	
如果前端页面包含上传文件的，传到后端后需要把request.FILES绑定
def new_article(request):
	form=forms.ArticleForm(request.POST,request.FILES)   #post和files绑定
	if request.method == 'POST':
		if form.is_valid():
			form_data=form.cleaned_data
			form_data['author_id']=request.user.userprofile.id
			file_obj=request.FILES.get('head_img')
			file_name=file_obj.name
			upload_dir='static/imgs/uploads/%s' % request.user.userprofile.id   #上传到static/imgs/uploads/用户id
			if not os.path.exists(upload_dir):
					os.mkdir(upload_dir)
			new_upload_dir='imgs/uploads/%s' % request.user.userprofile.id  #这是数据库里面记录的路径,因为前端展示只是/static/upload_dir
			f=open('%s/%s' % (upload_dir,file_name),'wb')
			for line in file_obj.chunks():
					f.write(line)
			f.close()
			form_data['head_img']='%s/%s' % (new_upload_dir,file_name)
			new_article_obj=models.Article(**form_data)   #如果这里直接使用models.Article.objects.create(**form_data)返回值只是成功或者失败
			new_article_obj.save()   #这样创建还可以返回一个对象
			return render(request,'new_article.html',{'ArticleForm':form,'new_article_obj':new_article_obj})
		else:
				err_msg=form.errors
	return render(request,'new_article.html',{'ArticleForm':form})
	new_article_obj返回时可以做一个判断:
	{% if not new_article_obj %}
		xxxxxxx
	{% else %}
		xxxxxxx
	{% endif %}
	
	一个开源的富文本编辑器ck-editor,需要在textarea里面加上class='ckeditor'
	引入js
	{% block head-js %}
        <script type="text/javascript" src="/static/plugins/ckeditor/ckeditor.js"></script>
    {% endblock %}
	<textarea class='ckeditor' id='id_content'></textarea>
	{% block bottom-js %}
	<script>
        CKEDITOR.replace('id_content');
        CKEDITOR.editorConfig = function( config ) {
            config.skin = 'v2';
            config.uiColor = '#FFF';
            config.height = 500;
            config.toolbarCanCollapse = true;
        };
    </script>
	{% endblock %}
###################################################################
多级评论树:
前端html
{% autoescape off %}   #关闭对html的转义
    {% build_comment_tree article.comment_set.select_related %}
{% endautoescape %}

#article.comment_set.select_related  ==  comment_list
主要是在后端实现,在simpletags完成对多级评论的分组和封装
simpletags:
from django import template
from django.utils.safestring import mark_safe
import time,datetime
import math
import collections 
 
register = template.Library()

@register.simple_tag
def build_comment_tree(comment_list):
	#对多级论进行分组
	comment_list=comment_list.order_by('date')   #按照评论时间进行排序
	data_dict =collections.OrderedDict()
	for comment_obj in comment_list:
			if comment_obj.parent_comment is None:
				data_dict[comment_obj] ={}
			else:
				tree_search(data_dict,comment_obj)
	#封装成html
	html="<div>"
	margin_left=0
	html+="<p>%s:(%s)</p>" % (u'最新评论',comment_list.count())
	for k,v in data_dict.items():
		#处理时间
		date1="%s" % k.date   #2016-09-22 10:06:23+00:00
		date1=date1.split('+')[0]
		date1=time.strptime("%s" % date1,"%Y-%m-%d %H:%M:%S")
		date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])
		seconds=(datetime.datetime.now()-date1).seconds
		times=changeTime(seconds)
		html+="<div class='comment_line'><span style='color:lightblue'>"+k.user.name+"</span>:  "+k.comment+"  <span style='color:#ccc'>%s %s</span></div>" % (times,u'前发布')
		html+=generate_comment_html(v,margin_left+25)
	html+="</div>"
	return html

def tree_search(d_dic,comment_obj):
    for k,v_dic in d_dic.items():
        if k == comment_obj.parent_comment:
            d_dic[k][comment_obj] = {}
            return
        else:
            tree_search(d_dic[k],comment_obj)

def generate_comment_html(d,margin_left_val):
	html=""
	for k,v in d.items():
		date1="%s" % k.date
		date1=date1.split('+')[0]
		date1=time.strptime("%s" % date1,"%Y-%m-%d %H:%M:%S")
		date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])
		seconds=(datetime.datetime.now()-date1).seconds
		times=changeTime(seconds)
		html+="<div class='comment_line' style='margin-left:%spx'><span style='color:lightblue'>"% margin_left_val+k.user.name+"</span>: "+k.comment+"  <span style='color:#ccc'>%s %s</span></div>" % (times,u'前发布')
		if isinstance(v,dict):
				html+=generate_comment_html(v,margin_left_val+25)
	return html

def changeTime(allTime):  
    day = 24*60*60  
    hour = 60*60  
    min = 60  
    if allTime <60:          
        return  "%d sec"%math.ceil(allTime)  
    elif  allTime > day:  
        days = divmod(allTime,day)   
        return "%d days, %s"%(int(days[0]),changeTime(days[1]))  
    elif allTime > hour:  
        hours = divmod(allTime,hour)  
        return '%d hours, %s'%(int(hours[0]),changeTime(hours[1]))  
    else:  
        mins = divmod(allTime,min)  
        return "%d mins, %d sec"%(int(mins[0]),math.ceil(mins[1])) 	
###############################################################################
在models.py:
class Comment(models.Model):
        article=models.ForeignKey('Article')
        user=models.ForeignKey('UserProfile')
        #自关联
        #相当于parent_comment=models.ForeignKey('comment')
        parent_comment=models.ForeignKey('self',related_name='p_comment',blank=True,null=True)
        comment=models.TextField(max_length=1000)
        date=models.DateTimeField(auto_now=True)

        def __unicode__(self):
                return "%s" % (self.comment)

                class Meta:
                        ordering=['date']	#设置按照日期排序,除非使用order_by特别指定，否则都会只用date排序
##############################################################################
分页
取前10条:
models.xx.objects.all()[0:10]
代码(views.py)
from django.shortcuts import render
from pager import models
# Create your views here.
class pager(object):

	def __init__(self,current_page):
		self.current_page=current_page

	@property
	def start(self):
		return (self.current_page-1)*10

	@property
	def end(self):
		return self.current_page*10

	def generate_pager_str(self,pager_num,pager_url):
		if self.current_page<=6:   #保持11行
			start=1
			end=12
		elif self.current_page > pager_num-6:
			start=pager_num-10
			end=pager_num+1
		else:
			start=self.current_page-5
			end=self.current_page+6
		pager_list=[]
		for i in range(start,end):
			if i == self.current_page:
				temp="<a style='color:red;font-size:20px' href=%s%d>%d</a>" % (pager_url,i,i)
			else:
				temp="<a href=%s%d>%d</a>" % (pager_url,i,i)
			pager_list.append(temp)

		#首页
		first_page="<a href=%s%d>首页</a>" % (pager_url,1)
		#末页
		last_page="<a href=%s%d>末页</a>" % (pager_url,pager_num)
		#上一页
		if self.current_page > 1:
			pre_page="<a href=%s%d>上一页</a>" % (pager_url,self.current_page-1)
		else:
			pre_page="<a href='javascript:void(0)'>上一页</a>"
		#下一页
		if self.current_page < pager_num:
			next_page="<a href=%s%d>下一页</a>" % (pager_url,self.current_page+1)
		else:
			next_page="<a href='javascript:void(0)'>下一页</a>"

		pager_list.insert(0,first_page)
		pager_list.insert(1,pre_page)
		pager_list.append(next_page)
		pager_list.append(last_page)
		return ''.join(pager_list)

def user_list(request):
	current_page=int(request.GET.get('page'))
	page_nums=models.UserList.objects.all().count()
	quotient,reminder=divmod(page_nums,10)
	if reminder>0:
		pager_num=quotient+1
	else:
		pager_num=quotient   #30
	p=pager(current_page)
	pager_str=p.generate_pager_str(pager_num,"/user_list/?page=")
	pager_obj=models.UserList.objects.all()[p.start:p.end]
	return render(request,'user_list.html',{'pager_obj':pager_obj,'pager_str':pager_str})
前端页面:
<div>
	<table border='1'>
	<tr><th>姓名</th><th>年龄</th></tr>
	{% for item in pager_obj %}
			<tr><td>{{item.username}}</td><td>{{item.age}}</td></tr>
	{% endfor %}
	</table>
	<div>
			{{pager_str|safe}}    
	</div>
</div>
#一般是对html页面不解析，加safe会解析
也可以在后端对html进行标记是安全的
from django.utils.safestring import mark_safe
return mark_safe(''.join(pager_list))
##################################################################################
bottle,flask
tornado支持异步非阻塞
异步非阻塞:
用户发来IO请求，立即返回，用户不接受结果，请求通过回调函数在后台自己处理，用户通过回调函数可以看到请求的结果

models.py
class UserType(models.Model):
    caption=models.CharField(max_length=20)

class user_info(models.Model):
	username=models.CharField(max_length=20)
	age=models.IntegerField()
	user_type=models.ForeignKey(UserType)

ORM:正向查找
models.user_info.objects.filter(user_type__caption='xxx');
def user_type(request):
    return HttpResponse('ok')

def user_info(request):
	#result=models.user_info.objects.all()
	#for item in result:
	#       print item.username,item.age,item.user_type.caption  #展示用.,user_type是一个对象里面存放的是id和caption组成的数据
	#dic={'username':'jack','age':35,'user_type':models.UserType.objects.get(id=2)}  #这样也可以
	#models.user_info.objects.create(**dic)
	result=models.user_info.objects.filter(user_type__id=2)
	result=models.user_info.objects.filter(user_type__caption='CEO')  #查询用__
	for item in result:
			print item.username,item.age,item.user_type.caption
	return HttpResponse('ok')
	
反向查找:_set的后面没有objects
def user_type(request):
	line=models.UserType.objects.get(id=2)
	print line.user_info_set.filter(username='jack')
	ret=models.UserType.objects.get(user_info__username='cash')    #这里的表名小写  #根据user_type表获取username='cash'的用户类型
	print ret.caption 
	print ret.user_info_set.all().count()   #获取这个类型的用户数，这里的表名也小写
	return HttpResponse('ok')

###################################################################################
多对多,反向添加
class Host(models.Model):
	hostname=models.CharField(max_length=32)
	port=models.IntegerField()
	#admin=models.ManyToManyField('Admin')   #或者在这边添加多对多关系也可以

	def __unicode__(self):
			return self.hostname

class Admin(models.Model):
	username=models.CharField(max_length=32)
	email=models.CharField(max_length=32)
	host=models.ManyToManyField(Host)  #第三张表

	def __unicode__(self):
			return self.username
			
def host(request):
	user_obj=models.Admin.objects.get(username='cash')
	hosts_list=models.Host.objects.filter(id__lt=3)
	user_obj.host.add(*hosts_list)   #add方法向第三张表里正向添加数据
	return HttpResponse('ok')
	
多对多反向添加:
def host(request):
	host_obj=models.Host.objects.get(id=3)
    admin_list=models.Admin.objects.filter(id__gt=2)
    host_obj.admin_set.add(*admin_list)
	
	host_obj=models.Host.objects.get(id=3)
	admin_obj=models.Admin.objects.get(id=1)
	host_obj.admin_set.add(admin_obj)    #添加单条数据不需要*号
####################################################################################
多对多自定义第三张表
class Host1(models.Model):
	hostname=models.CharField(max_length=32)
	port=models.IntegerField()

class Admin1(models.Model):
	username=models.CharField(max_length=32)
	email=models.CharField(max_length=32)
	host=models.ManyToManyField(Host1,through='HostRelation')   
	#通过through自定义第三张表,还可以在第三张表里定义其他字段,这个添加数据比较简单，推荐使用

class HostRelation(models.Model):
	h1=models.ForeignKey(Host1)
	a1=models.ForeignKey(Admin1)

添加数据:
def host(request):
	#第一种
	models.HostRelation.objects.create(
	       h1=models.Host1.objects.get(id=1),
	       a1=models.Admin1.objects.get(id=2),
	)
	#第二种
	models.HostRelation.objects.create(h1_id=2,a1_id=3)
	models.HostRelation.objects.create(h1_id=1,a1_id=3)
	return HttpResponse('ok')
推荐使用自定义第三张表的形式
多对多第一种
正向查找:
admin_obj=models.Admin.objects.get(id=1)
admin_obj.host.all()/filter()

反向查找
host_obj=models.Host.objects.get(id=1)
host_obj.admin_set.all()/filter()

多对多第二种:
relation_list=models.HostRelation.objects.all()/filter()
relation_list.query  #查看使用了什么样的sql语句
for item in relation_list:
	print item.h1.hostname
	print item.a1.username
	
一对一正反向都一样:
没有_set
asset_number_obj=models.HostList.objects.get(number=search_asset)
asset_number_id=asset_number_obj.assets.asset_number_id
class Assets(models.Model):
        asset_number=models.OneToOneField(HostList)
		
class HostList(models.Model):
        number = models.CharField(max_length=30,unique=True,verbose_name=u'资产编号')
######################################################################
select_related:优化外键的查询，会把外键相关的表全部查到	
class UserType(models.Model):
    caption=models.CharField(max_length=20)

class UserInfo(models.Model):
	username=models.CharField(max_length=20)
	age=models.IntegerField()
	user_type=models.ForeignKey(UserType)
	
user_obj=models.UserInfo.objects.all().select_related()
user_obj.user_type.caption
这样可以少查询一次，查询一次就可以了

F用法:专门去对象中某列值的操作
F指的是当前行的age
models.user_info.objects.all().update(age=F('age')+1)
models.user_info.objects.filter(username='cash').update(age=F('age')+10)
cash_obj=models.user_info.objects.get(username='cash')
cash_obj.age=F('age')-11;
cash_obj.save()

Q 构建搜索复杂的搜索条件
from django.db.models import Q
con = Q()

q1 = Q()              #利用第一个字段构建第一个Q对象
q1.connector = 'OR'   #下面条件的连接符都是or
q1.children.append(('id', 1))
q1.children.append(('id', 10))
q1.children.append(('id', 9))

q2 = Q()            
q2.connector = 'OR'
q2.children.append(('c1', 1))
q2.children.append(('c1', 10))
q2.children.append(('c1', 9))

con.add(q1, 'AND')
con.add(q2, 'AND')

models.Tb1.objects.filter(con)

也可以这样用:
search_asset_obj=models.Assets.objects.filter(Q(asset_number_id=asset_number_id)|Q(hostname__icontains=search_asset)|Q(InnerIp__contains=search_asset))
~Q代表否的意思

Q对象可以与关键字参数查询一起使用，不过一定要把Q对象放在关键字参数查询的前面。
正确：
Poll.objects.get(
Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
question__startswith='Who')

错误：
Poll.objects.get(
question__startswith='Who',
Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)))

Restful API接口规范
URL中不能有动词

世界上最安全且最简单的安全认证:
server端存放client端的token
client端的token存放于配置文件里，不需要通过server端来获取
当client端来认证时，通过传送时间戳，用户名和加密的token（时间戳加token进行加密）的方式来认证，
server收到请求，通过用户名取出该client的token，然后加密同client端传送过来的token加密信息进行
对比，相同则通过，然后将这个请求的缓存放到一个redis或者什么地方，设置一个过期时间，超过这个
过期时间来的请求都被认为是无效的