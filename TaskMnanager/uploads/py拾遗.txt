"""
""" 多行注释
#   单行注释

索引的形式:
name="I'm {0},age {1}"   或 name="I'm {aa},age:{bb}"
name.format("cash",28)   或 name.format(aa='cash',bb=28)
"I'm cash,age 28"
new_name=name.format("cash",28)
print new_name
还有两种形式：
1，列表形式
str="My name is {0} and I'm {1} years old"
info_list=['cash',27]
str.format(*info_list)
2,字典形式
str="My name is {ss} and I'm {dd} years old"
info_dict={'ss':'cash','dd':27}
str.format(**info_dict)


print
"""
c
a
s
h
"""
输出：
c
a
s
h

id(a),查看内存地址

a=['a','b','c','d']
del a[0]
a.remove('a')


在python里，变量只要在内存里存在，就能使用

python的三元运算符
name='cash'
res='good' if name=='cash' else 'bad'   #输出good
python变量区分大小写
#######################
name='cash'
type(name)--->得到类型
dir(类型）
help(类型）
dir(list)
help(list)
######################
十六进制:hex()
八进制:oct()

name='cashingcao'
name.center(10,'*')   输出***cash***
name.count('c')       输出2
name.count('a',1,5)   输出1

name=u'曹帅'
name.encode('utf-8')   //曹帅
name='曹帅'
name.decode('gbk').encode('utf-8')  //将gbk编码转化成utf8编码

expandtabs()将tab键转化成几个空格，默认8个空格
name='cas	h'
name.expandtabs(2)   #将name中的tab键转化成2个空格

find()找到字符的位置
name='casha'
name.find('a')   #1,只找第一个
name.find('sh')  #2
name.find('b')   #-1,没找到-1

index()返回字符的位置
找不到就报错

str.isalnum()   返回True or False
isalnum()是否是数字和字母组成
isalpha()
isdigit()是否是数字
islower()
isupper()
isspace()
ljust()内容左对齐，右边填充name='hello world' name.ljust(15,'*')  //hello world****
rjust()
lower()和upper()
swapcase()大写变小写，小写变大写
lstrip()和rstrip()，strip同时可以去掉换行符'\n'
partition()分隔
name="Hello,cash"
name.partition('ll')   #分割成3部分["He","ll","o,cash"]
replace()替换
rfind()从右边开始找
rindex()
rpatition()
rsplit()
splitlines()按换行分割
f=file('xx','r')
str=f.read()
str.splitlines() #按照换行进行分割
zfill()
name='cash'
name.zfill(6)   #00cash
istitle()  title()转化成标题格式

#####替换单个字符######
import string
a='abcde'
b='12345'
str="hello,cash"
trantab=string.maketrans(a,b)
print str.translate(trantab,'XX')   //xx参数表示删除的字符集合
#######################

中文按照unicode比较

字典：
d.get('a','ok')    //如果a不存在的话，返回ok
d.fromkeys(('a','b','c'),1) {'a':1,'b':1,'c':1} #第二个参数默认是NONE
d.pop('a')  #返回对应的value
d.popitem() #返回随机删除的键值
del d['a']  #不返回任何内容
d.setdefault('a',1) #查找键值，如果键值不存在则加进去，第二个参数为value值，默认为None

深拷贝和浅拷贝
import copy
a=[1,2,3,[4,5,6]]
b=copy.copy(a)
c=copy.deepcopy(a)
a[3].append(7)
b ---->     [1,2,3,[4,5,6,7]]
c ---->     [1,2,3,[4,5,6]]

collection模块：
1，计数器counter:
d1=collections.Counter('dwerewsr')
返回Counter({'w': 2, 'r': 2, 'e': 2, 'd': 1, 's': 1})
d1.most_common(3)返回[('w', 2), ('r', 2), ('e', 2)]
d1.update('p')  //增加一个'p':1
d1.update(d2)    //会将d1和d2存在的元素个数相加
d1.clear()   //清空
for i in d1.elements():
	print i
//列出所有元素
d1.subtract() //相减
li=[11,22,33,44,44,33,22,11]
d2=collections.Counter(li);   //传递列表进去，得到列表中元素的个数，也可以是元组

2,有序字典OrderedDict
o=collections.OrderedDict()
o['k1']=1
o['k2']=2
o['k3']=3
//输出OrderedDict([('k1', 1), ('k2', 2), ('k3', 3)])

3，defaultdict()  创建value是列表的字典
d1=collections.defaultdict(list)
d1['k1'].append(1)
d1['k2'].append(2)
//输出defaultdict(<type 'list'>, {'k2': [2], 'k1': [1]})

4，namedtuple命名空间
mytuple=collections.namedtuple('ituple',['x','y'])
n=mytuple(1,2)
n.x  ---->1
n.y  ---->2

5,双向队列deque，线程安全，多个线程同时来取，一个在拿时，会加锁，保证不会出现抢占资源的发生
append()
appendleft()
count()
extend()
extendleft()
pop()   删除最后一个，并返回
popleft()
remove()
clear()
reverse()
rotate()  //移动，为整数则向右移动，负数则像左，默认是1


Queue单向队列，先进先出 FIFO
q=Queue.Queue(10)   //最多创造10条队列
q.put(1)
q.put(2)
q.put(3)
q.get()  //1
q.get()  //2
q.get() //3
栈:先进后出，像弹夹

迭代器：
冒泡算法
li=[13,22,6,99,11]

for i in range(len(li)-1):               或     for i in range(1,len(li)):
         for j in range(i+1,len(li)):			for j in range(len(li)-1)
                if li[i]>li[j]:
                        temp=li[j]
                        li[j]=li[i]
                        li[i]=temp
print li
找一个中间值

内置函数
vars（）获取当前文件的所有变量
print __file__     //获取当前文件的绝对路径
print __doc__     //获取文件头部的注释
print Queue.__doc__  //获取Queue模块头部的注释
print __name__ 为main表示是主文件,会被执行

被执行的脚本的__name__等于main，
如果之前已经导过了某个模块，而这个模块修改的话，在不kill程序的情况下，可以用reload该模块就会重新导入
reload()
max(),min(),sum()
divmod(10,3)     //返回（3，1）
all(序列)，序列中的值都是真的，才为真
any(序列)，有一个为真，就为真
chr()和ord()  ASCII码和字符转换，ord('A')和chr(65)
hex(),oct(),bin()---->16进制,8进制,2进制
li=[11,22]
for k,v in enumerate(li):
	print k,v
输出：
0，11
1，22

enumerate(li,1)--->从1开始

##########################
函数之动态参数1:
def func(*args):
	print arg

func(1,2,3,4)   //返回一个元组(1,2,3,4)
t=('a','b','c','d')  //列表也可以
func(*t)       //返回('a','b','c','d')
函数之动态参数2：
def func(**kwargs):
	print kwargs
func(a=1,b=2)   //返回{'a':1,'b':2}
dic={'a':1,'b':2}
func(**dic)         //返回{'a':1,'b':2}
联合使用：
def func(*args,**kwargs):
	print args
	print kwargs
func(1,2,3)   //返回(1,2,3)
func(a=1,b=2)  //返回{'a':1,'b':2}
func(1,2,3,a=1,b=2}  //返回(1,2,3,'a':1,'b':2)

推荐使用open打开文件
f=open('1.txt')
f.seek(5)
f.tell()   //5
f.read()
f.tell()

字符串替换：
str="Hello world"
str=str[:7]+"cash"
str    //输出Hello cash

文件打开模式：
w==w+,a==a+
r+既可以读又可以写
f.truncate()   //截断数据，根据指针当前的位置
f.truncate(5)   //从指针5开始的位置，开始截断
处理二进制文件的时候需要加上b
windows生成的文件需要以rb方式打开
U方式会把\r\n转换成\n,只能与r一起使用rU
在windows下面编辑的文件换行符是\r\n,替换成\n，就用rU模式打开文件

with open('1.txt','r') as f:
	print f.read()
python2.7以后，with 可以同时操作两个文件
with open('1.txt','r') as f1,open('2.txt','w') as f2:
	for line in f1:
		f2.write(line)

lambda表达式(也可以传动态参数)：
fun=lambda a,b:a+b
result=fun(2,3)
fun2=lambda:**kwargs:kwargs['a']+kwargs['b']
d={'a':1,'b':2}
fun2(**d)

filter()返回True的值
li=[11,22,33,44,55]
print filter(lambda a:a>33,li)    //返回[44,55]
print filter(None,li)    //返回真的

map()遍历序列中的元素，对序列中的每个元素进行操作
def func(arg):
	return arg+1;
li=[1,2,3,4]
print map(func,li)

def func2(a,b):
	return a+b
l1=[1,2,3,4]
l2=[5,6,7,8]
print map(func2,l1,l2)   //[6,8,10,12]
print map(lambda a1,a2:a1+a2,l1,l2)

reduce()对序列中的元素进行累计操作
li=[1,2,3,4]
print reduce(lambda a1,a2:a1+a2,li)   //累加操作:10
print reduce(lambda a1,a2:a1+a2,li,100)  //100作为基数，110

yield记住上一次操作，下次在执行时，继续执行
def func():
	yield 1
	yield 2
	yield 3

for i in func():
	print i

def func(arg):
        seed=0
        while True:
                seed=seed+1
                if seed > arg:
                        return     #退出函数
                else:
                        yield seed

for i in func(10):
        print i
输出1，2，3，4，5，6，7，8，9，10

装饰器,为函数或类增加一些功能,使用装饰器可以在函数执行前和执行后添加相应操作
import functools

def checkLogin(user='cash'):
        def decorator(func):
		@functools.wraps(func)
                def wrapper(*args,**kwargs):
                        if user == 'cash':
                                print 'Hello %s' % user
                                return func(*args,**kwargs)
                        else:
                                print 'Invalid username: %s' % user
                return wrapper
        return decorator

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print 'call %s():' % func.__name__
        return func(*args, **kwargs)
    return wrapper


#home=checkLogin(home)('cash')
@checkLogin    #装饰器
#@log
def home():
        print 'Home page'

home()

参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance
if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')

生成器：g = (x * x for x in range(10))   返回一个生成器
可以使用g.next()一个个打印出来
也可以使用for i in g:
		print i

#################################
装饰器：
导入模块import base
使用base.py里面的函数 base.f1()
base.py:
def auth(func):
        def wrapper(*args,**kwargs):
                print 'before'
                func(*args,**kwargs)
                print 'after'
        return wrapper

@auth
def func1(arg):
        print '%s' % arg

index.py:
import base
base.func1('Hello')
###############################
装饰器登陆验证
def login():
	name='cash';
	if name=='cash':
		return True;
	else:
		return False;

def auth(func):
	def wrapper(*args,**kwargs):
		print 'before';
		is_login=login()
		if not is_login:
			return 'Invalid user'
		temp=func(*args,**kwargs)
		print 'after'
		return temp
	return wrapper

@auth
-----------------------------
def login(name):
	local_name='cash'
	if local_name == name:
		return True
	else:
		return False

def auth(func):
	def wrapper(*args,**kwargs):
		name=kwargs.pop('token')    //再不改变原函数参数的情况下的解决办法
		print 'before'
		is_login=login(name)
		if not is_login:
			return 'Invalid user'
		temp=func(*args,**kwargs)
		print 'after'
		return temp
	return wrapper

@auth
def func(arg):
	return arg

import base
res=base.func('a',token='cash')

多装饰器,可以对一个函数使用多个装饰器
def auth1(func):
	def wrapper():
		print 'auth1 before'
		func()
		print 'auth1 start'
	return wrapper
def auth2(func):
	def wrapper():
		print 'auth2 before'
		func()
		print 'auth2 start'
	return wrapper

@auth2
@auth1
def func():
	print 'foo'
auth2装饰器会把auth1包裹起来
auth2 before
auth1 before
foo
auth1 after
auth2 after
适用于登陆验证时权限的判断，登录通过了，还要继续判断权限

函数递归：
#!/bin/env python

def func(arg1,arg2):
        if arg1 == 0:
                pass
        arg3=arg1+arg2
        if arg3>10:
                return arg3
        return func(arg2,arg3)    #函数里不加return则返回None

res=func(0,1)
print res


模块的函数重命名
from sys import argv as test

sys.path.append('xxx')   //增加一个存放模块的路径
print sys.path    //查看存放模块的路径

在一个文件夹下放了很多需要导入的py文件，这个文件下面还需要建立一个__init__.py的文件，这样的文件夹会被看成一个包
文件夹：modules 下面py文件：__init__.py,a.py
from modules import a    //输出a.py里面的内容

test.py:
import sys
sys.stdout.write('')不会换行，print会换行

while True:
        file=sys.stdin.readline()    //一行行输出
        if not file:break
        print file.strip()

file=sys.stdin.read()      //全部输出
print file

cat file.txt | python test.py

md5模块   #即将被放弃
import md5
hash=md5.new()
hash.update('cash')
print hash.hexdigest()

hashlib模块   #统一的加密模块
import hashlib
hash=hashlib.md5('xxx')   //加盐
hash.update('cash')
print hash.hexdigest()

更牛叉的加密模块：hmac模块
import hmac
hash=hmac.new('xxx')   //随机加盐
hash.update('cash')
print hash.hexdigest()

面向对象(oop)，提高软件的重用性，灵活性和扩展性
__ini__初始化对象，在实例化对象的时候自动执行

p1=person('cash')   //实例化对象
class person(object):
        def __init__(self,name):     #self相当于p1和p2
                self.name=name

#self相当于p1,p2,代表实例本身,self.name相当于p1.name,p2.name
        def say(self):
                print 'My name is %s' % self.name

        def eat(self):       //必须要有self
                print '%s is eating' % self.name

p1=person('gf1')
p2=person('gf2')
p1.eat()
#person.eat(p1)
p2.eat()
如果不初始化，那需要这样赋值
p1=person()
p1.name='gf1'
p1.say()

random模块：
print random.random()  //0-1之间的小数
print random.randint(1,2) //1和2之间的整数
print random.randrange(1,2) //1和2指尖的证书，包括1但不包括2
chr()和ord()

新式类：
class M(object):
	pass

class S(M):
	pass
经典类：
class M:
	pass
使用新式类，继承object，多继承，一个类可以继承多个类

经典类（深度查找）：
class D:

    def bar(self):
        print 'D.bar'


class C(D):

    def bar(self):
        print 'C.bar'


class B(D):

    def bar(self):
        print 'B.bar'


class A(B, C):

    def bar(self):
        print 'A.bar'

a = A()
# 执行bar方法时
# 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错
# 所以，查找顺序：A --> B --> D --> C
# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了
a.bar()   //输出A.bar，如果A中没找到，找B，B中有的话，输出B.bar，否则D.bar,D中还没找到的话，就到C，C中存在的话输出C.bar,宽度优先的前提必须是B和C都继承D，否则不支持，假设C没继承D，如果B中存在的话，则输出B.bar,如果B没继承的话，B中有值的话，就输出B.bar,没值则输出D.bar

新式类（宽度查找）：
class D(object):

    def bar(self):
        print 'D.bar'


class C(D):

    def bar(self):
        print 'C.bar'


class B(D):

    def bar(self):
        print 'B.bar'


class A(B, C):

    def bar(self):
        print 'A.bar'

a = A()
# 执行bar方法时
# 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错
# 所以，查找顺序：A --> B --> C --> D
# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了
a.bar()
类成员里面包括字段，方法和属性
obj.func()   //方法
obj.attr   //属性,需要加装饰器@property,把方法伪造成字段
class foo:
	@property
	def attr(self):   //只能有一个self属性
		pass
另外一种方法,执行property方法：attr2=property(attr)
obj=foo()
obj.attr2

字段包括静态字段和普通字段，普通字段属于对象，静态字段属于类
class Province:

    # 静态字段
    country ＝ '中国'

    def __init__(self, name):

        # 普通字段
        self.name = name


# 直接访问普通字段
obj = Province('河北省')
print obj.name

# 直接访问静态字段，不要这样访问obj.country
Province.country

方法包括普通方法，类方法和静态方法
普通方法：
对象调用

类方法：
类调用
class Person:	
	@classmethod
	def f2(cls):   //只能有一个参数cls（class)
		print cls
Person.f2()    //类Person会把自己当作参数传给f2

静态方法：
类调用
class Person:
	@staticmethod
	def f3(a1,a2):   //不再使用self，可以加任意参数，相当于是一个函数，不需要通过对象来调用，省了内存
		pass
Person.f3(1,2)

私有属性'__'
class Foo(object):
	__country='china'

	def __init__(self):
		self.__name='cash'   //私有字段

	def f1(self):
		print self.__name

	def __f2(self):    //私有方法
		print 'f2'

推荐私有属性，通过间接的方式进行访问
Foo.__country   //无法访问
obj=Foo()
obj.__name     //无法访问
obj._Foo__name   //可以访问，不推荐使用
Foo._Foo__country   //可以访问，不推荐使用
obj.__f2()     //无法访问
继承的子类也不能访问父类的私有属性，只能父类自己在内部使用

类的特殊方法
#####################################################################
Foo.__doc__   //注释
__del__析构方法，python解释器会自动释放内存
__call__
__dict__
__str__

class Foo(object):
	def __call__(self):
		print 'call'

obj=Foo()
obj()    //call

class Foo(object):
	def __init__(self):
		self.name='cash'

	def __str__(self):
		return 'cash'

obj=Foo()
obj.__dict__  //{'name':'cash'}查看对象中有什么
Foo.__dict__   //查看类中有什么
obj     //cash
Foo类是由type类实例化产生

__iter__ ，用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了__iter__ 
class Foo(object):

    def __init__(self, sq):
        self.sq = sq

    def __iter__(self):
        return iter(self.sq)

obj = Foo([11,22,33,44])

for i in obj:
    print i
#######################################################################################
isinstance(n,int)   //判断n是否是int类型
issubclass(B,A)    //判断B是否是A的子类（派生类）
异常：
Exception万能异常
try:
	xxxx
except IndexError,e:
	print e
except KeyError,e:
	print e
except Exception,e    //在最下面定义万能异常
	print e
主动触发异常 raise Exception('错误')
try:
	xxxx
	if xxx:
		xxxx
	else:
		raise Exception('error')
except Exception,e:
	print e    //e里面封装了主动触发里面的'error'
try:
	xxxx
except Exception,e
	print e
else:                    //未出现异常时执行
	pass
finally:                 //无论是否出现异常，都要执行
	一般用于断开连接，释放资源时使用
	pass
e对象调用的是Exception类里面的__str__方法
自定义异常
class Myexception(Exception):
	
	def __init__(self,msg=None):
		self.msg=msg

	def __str__(self):
		if self.msg:
			return self.msg
		else:
			return 'Error'

try:
	raise Myexception('错误')
except Myexception,e:
	print e             //返回错误

断言
assert 条件    //条件不满足时，报错

反射：
通过getattr内置函数寻找函数
import home

url=raw_input('url:')
controller,action=url.split('/')
func=getattr(home,action)   //返回action函数
is_exist=hasattr(home,action)  //判断home模块(home.py)里面函数存不存在
ret=func()
print ret
#getattr,setattr,delattr,hasattr  反射的四个内置函数
import home    #将里面的函数已经加载到内存里面了，通过dir(home)查看
setattr(home,'cash','good boy'或函数)  //在home的内存里面已经有了cash的函数
delattr(home,'dev') //内存里面已经删了dev函数，文件里面没删
通过反射操作函数和类
import home
cls=getattr(home,'Foo')   //home.Foo，在外部文件里获取
obj=cls()
name=getattr(obj,'name')
s_name=getattr(cls,'static_name')

hasattr(Foo,'static_name')   //判断类里面有没有该成员,在一个文件里获取
obj=Foo()
hasattr(obj,'xxxx')   //判断对象里面有没有成员
动态模块导入：
controller,action=raw_input('url').split('/')    #home/dev
module=__import__(controller) 相当于 import home as module   #模块作为动态参数导入

单例模式：内存中只存在一个实例
class sqlHelper():
	_static_instance=None    //用来保存永远存在于内存的实例

	def __init__(self):
		self.host='1.1.1.1'
		self.port=3306
		self.user='root'
		self.passwd='123'
	
	@classmethod
	def instance(cls):
		if cls._static_instance:
			return cls._static_instance
		else:
			cls._static_instance=sqlHelper()
			return cls._static_instance

	def fetch(self):
		pass

def get_user():
	obj=sqlHelper()    //会不断创建，有无数个实例，python解释器的垃圾回收机制并不能立刻回收，这时候就需要创建一个单独的实例了
			   //单例模式不适用于高并发的情况下，因为只有一个实例在处理请求，会出问题
	obj.fetch()

def get_user():
	obj=sqlHelper.instance()   //单例模式，调用永远保存在内存里的那个实例
	obj.fetch

socket:创建tcp连接
socket服务端：
import socket

def main():
	#创建socket对象
	sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	#监听端口
	sock.bind(（'127.0.0.1',8001))  #元组
	#开始监听连接，在排队的最大连接数
	sock.listen(5)

	while True:
		connection,address=sock.accept()
		#connection：客户端socket对象,address：客户端IP地址
		#最多能接收1024字节，不是一次接收1024字节，阻塞等待客户端发送数据
		buf=connection.recv(1024)
		print buf
		connection.send('HTTP/1.1 200 OK\r\n\r\n')   #sendall一次性全部发送
		connection.send('Hello world')
		connection.close()

if __name__='__main__':
	main()	

参数说明：
socket.AF_INET IPV4(默认）
socket.AF_INET6 IPV6

socket.SOCK_STREAM 流式socket,用于tcp,默认
socket.SOCK_DGRAM 数据报式socket,用于udp

第三个参数，默认为0，自动选择一个合适的协议

obj_server.setblocking(False)   //不用，则在accept（connection,address=sock.accept(）时阻塞，会结合select，epoll和poll时候使用
connect_x   #连接不成功时不报错，成功返回0，失败则返回一个编码

obj_client.settimeout()   #超时时间，适用于客户端
obj_client.getpeername()  #返回服务器的ip和端口，适用于客户端
obj_server.getsockname()  #返回自己的ip和端口，适用于服务端
obj.fileno() #套接字的文件描述符

socket客户端：
import socket
obj=socket.socket()
obj.connect('localhost',8341)
obj.send('xxxx')
server_data=obj.recv(1024)
print server_data
obj.close()

socket模块同时只能处理一个请求
socketserver支持多线程同时处理多个请求
服务端：
import SocketServer

class MyServer(SocketServer.BaseRequestHandler):

    def handle(self):               #必须是handle
        # print self.request,self.client_address,self.server
        conn = self.request
	print 'Client address:%s' % self.client_address
        conn.sendall('')
        Flag = True
        while Flag:
            data = conn.recv(1024)
            if data == 'exit':
                Flag = False
            elif data == '0':
                conn.sendall('通过可能会被录音.balabala一大推')
            else:
                conn.sendall('请重新输入.')


if __name__ == '__main__':
    server = SocketServer.ThreadingTCPServer(('127.0.0.1',8009),MyServer)
    server.serve_forever()

客户端：
import socket


ip_port = ('127.0.0.1',8009)
sk = socket.socket()
sk.connect(ip_port)
sk.settimeout(5)

while True:
    data = sk.recv(1024)   //收不到数据会阻塞
    print 'receive:',data
    inp = raw_input('please input:')
    sk.sendall(inp)
    if inp == 'exit':
        break

sk.close()

hasattr(sys.modules[__name__],'Foo')  //判断当前模块中是否有Foo方法
如果想要加载一个目录下的py文件，需要先加到环境变量里，sys.path.append('xxx')

IO多路复用，可以监听多个文件描述符,单线程
python中的select模块，提供了select,poll,epoll三个方法，分别调用系统的select,poll,epoll来实现多路复用
windows python:select,Mac：select,Linux:select,poll,epoll

监听用户输入，用户输入内容，select感知sys.stdin改变，将改变的文件句柄保存至列表，并将列表作为select第一个参数返回，如果用户未输入内容，那么第一个参数就为空列表

import select
import sys

while True:
	readable,writeable,error=select.select([sys.stdin,],[],[])
	print readable    //[<open file '<stdin>', mode 'r' at 0x7f60145950c0>]
	if sys.stdin in readable:
		print 'select get stdin',sys.stdin.readline()

select监听多个句柄

------------服务端------------------------------------------
#可以接收多个客户端的连接
ip_port = ('127.0.0.1',8009)
sk = socket.socket()
sk.bind(ip_port)
sk.listen(5)
sk.setblocking(False)   //sk.accept时不阻塞

ip_port = ('127.0.0.1',9009)
sk1 = socket.socket()
sk1.bind(ip_port)
sk1.listen(5)
sk1.setblocking(False)
inputs=[sk,]

while True:
	#监听句柄序列，某一个变化，就获取那一个，sk跟监听客户端连接有关，conn跟客户端发送数据有关
	rList,w,e=select.select(inputs,[],[],2)   //可以监听多个句柄
	for r in rList:
		if r == sk:    #判断是否是服务端的句柄
			#conn:客户端的句柄
			conn,addr=r.accept()
			print addr
			inputs.append(conn)
		else:
			client_data=r.recv(1024)
			if client_data:         
				r.sendall(client_data)
			else:
				inputs.remove(r)        #客户端在断开连接的时候会发送一个空数据，当收到空数据的时候就从监听的句柄序列里删除该句柄

--------客户端--------------------------------------------
import socket

sk=socket.socket()
sk.connect(('127.0.0.1',8008))
sk.settimeout(30)

while True:
        input=raw_input('请输入:')
        sk.sendall(input)
        data=sk.recv(1024)
        print 'Result:%s' % data

sk.close()
--------------------------------------------------------
select模块:第一个参数代表监听句柄的序列，只有发生变化，才能获取得到
	   第二个参数只要监听的句柄存在，就能获取得到，无论是不是变化
	   第三个参数检测监听的句柄是否出现异常，会把异常放到e里面
	   第四个参数不写会阻塞住，一直等待监听句柄的变化，阻塞的时间，假设1s的话，会每1s继续往下执行
output=[]
rList,w,e=select.select(inputs,output,inputs,2)

----------------------------------------------------------------
第二个参数是写，利用第二个参数来写
服务端：
ip_port = ('127.0.0.1',8009)
sk = socket.socket()
sk.bind(ip_port)
sk.listen(5)
sk.setblocking(False)   //sk.accept时不阻塞

inputs=[sk,]
outputs=[]

while True:
	#第二个参数监听句柄序列，只要存在就会感知
	rList,wList,e=select.select(inputs,outputs,inputs,1)   //可以监听多个句柄
	for r in rList:
		if r == sk:    #判断是否是服务端的句柄
			#conn:客户端的句柄
			conn,addr=r.accept()
			print addr
			inputs.append(conn)
		else:
			client_data=r.recv(1024)
			if client_data:         
				outputs.append(r)
	for w in wList:
		w.sendall('123')
		outputs.remove(w)     #要从监听句柄里删除，不然会一直发送数据
------------------------------------------------------------------
import Queue

obj=Queue.Queue()
try:
	print obj.get_nowait()
except Queue.Empty,e
	print e

obj.putnowait(x)
------------------------------------------------------------------------
#如果出现有若干个客户段同时向服务端发送数据，那么后发送的数据就会覆盖前面客户发过来的数据，为避免出现这种情况，故使用队列来先进先出

import socket
import select
import Queue

ip_port=('127.0.0.1',8808)
sk=socket.socket()
sk.bind(ip_port)
sk.listen(5)
sk.setblocking(False)

inputs=[sk,]
outputs=[]
message={}

while True:
        rList,wList,e=select.select(inputs,outputs,inputs,2)
        for r in rList:
                if r == sk:
                        conn,addr=r.accept()
                        print addr
                        inputs.append(conn)
                else:
                        client_data=r.recv(1024)
                        message[r]=Queue.Queue()
                        message[r].put(client_data)
                        if client_data:
                                outputs.append(r)
        for w in wList:
                try:
                        while not message[w].empty():
                                client_data=message[w].get()
                                w.sendall(client_data)
                except Queue.Empty,e:    #Queue.Empty继承了Exception异常类
                        print e
                outputs.remove(w)
-----------------------------------------------------------------------
SocketServer内部使用 IO多路复用 以及 “多线程” 和 “多进程” ，从而实现并发处理多个客户端请求的Socket服务端。即：每个客户端请求连接到服务器时，Socket服务端都会在服务器是创建一个“线程”或者“进程” 专门负责处理当前客户端的所有请求。
socketserver多进程多线程处理客户端请求   twitter murder bittornodo迅雷下载比特流协议
server = SocketServer.ThreadingTCPServer(('127.0.0.1',8009),MyServer)   #多线程
server = SocketServer.ForkingTCPServer(('127.0.0.1',8009),MyServer)     #多进程，调用的os.fork

######################################################################################
Twisted:基于事件驱动的网络框架，事件驱动分为两部分，首先是注册事件，然后是触发事件
#Twisted服务端
#!/usr/bin/env python
# -*- coding:utf-8 -*-

from twisted.internet import protocol
from twisted.internet import reactor

class Echo(protocol.Protocol):
    def dataReceived(self, data):
        self.transport.write(data)

def main():
    factory = protocol.ServerFactory()
    factory.protocol = Echo

    reactor.listenTCP(8000,factory)
    reactor.run()

if __name__ == '__main__':
    main()

#Twisted客户端
#!/usr/bin/env python
#-*-coding:utf8-*-

import socket

sk=socket.socket()
sk.connect(('127.0.0.1',8000))
sk.settimeout(30)

while True:
        cmd=raw_input('请输入:')
        sk.sendall(cmd)
        data=sk.recv(1024)
        print 'Result:%s' % data

sk.close()
####################################################################################
进程之间数据共享：
创建一个只包含数字类型的数组（列表），个数不可变
temp=Array('i',[11,22,33,44])   #i代表类型，还有L（长整型),可以被多个进程之间共享
print pool.apply(Foo,(1,))   #申请一个进程
pool.apply_async(func=Foo, args=(i,),callback=Bar)   #执行完之后在执行一个Bar函数，并把执行完获取的结果作为Bar的参数执行Bar函数
协程是由程序员控制的
IO操作比较多的话，用协程，线程之间会进行上下文的切换，导致效率降低

#####################################################################################
python线程
#!/usr/bin/env python
# -*- coding:utf-8 -*-
import threading
import time
  
def show(arg):
    time.sleep(1)
    print 'thread'+str(arg)
  
for i in range(10):
    t = threading.Thread(target=show, args=(i,))   #先输出'main thread stop'后，然后一次性开启10个线程执行show函数
    t.start()
  
print 'main thread stop'
#输出结果是（thread0-thread9一次性全部输出）：
main thread stop
thread0
thread1
thread2
thread3
thread4
thread5
thread6
thread7
thread8
thread9

start            线程准备就绪，等待CPU调度
setName          为线程设置名称
getName          获取线程名称
setDaemon        设置为后台线程或前台线程（默认）
                 如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，均停止
                 如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止
join             逐个执行每个线程，执行完毕后继续往下执行，该方法使得多线程变得无意义
run              线程被cpu调度后自动执行线程对象的run方法
如果设置t.setDaemon(True),那么上述代码只会输出 main thread stop，因为主线程已经执行完了，而后台线程不论是否执行完都会停止
如果在t.start()后面加上t.join(),那么输出的结果如下：
thread0
thread1
thread2
thread3
thread4
thread5
thread6
thread7
thread8
thread9
main thread stop
每隔1S执行一个线程，有点像队列了，线程失去了意义

import threading
import time


class MyThread(threading.Thread):
    def __init__(self,num):
        threading.Thread.__init__(self)    #这是经典类继承父类的构造方法的方式，新式类用super()
        self.num = num

    def run(self):#定义每个线程要运行的函数

        print("running on number:%s" %self.num)

        time.sleep(3)

if __name__ == '__main__':

    t1 = MyThread(1)
    t2 = MyThread(2)
    t1.start()   #自动调用run函数
    t2.start()   #同上
输出：
running on number:1
running on number:2
然后等待3S
#################################################################################
线程锁：防止多个线程修改同一数据时出现脏数据，同一时刻只允许一个线程操作
import threading
import time
   
gl_num = 0
   
lock = threading.RLock()
   
def Func():
    lock.acquire()   #上锁
    global gl_num
    gl_num +=1
    time.sleep(1)
    print gl_num
    lock.release()   #解锁
       
for i in range(10):
    t = threading.Thread(target=Func)
    t.start()
##################################################################################
信号量semaphore
线程锁只允许一个线程更改数据，而信号量则同时允许一定线程数量的线程更改数据
import threading,time
 
def run(n):
    semaphore.acquire()
    time.sleep(1)
    print("run the thread: %s" %n)
    semaphore.release()
 
if __name__ == '__main__':
 
    num= 0
    semaphore  = threading.BoundedSemaphore(5) #最多允许5个线程同时运行
    for i in range(20):
        t = threading.Thread(target=run,args=(i,))
        t.start()
会首先输出run the thread: 0到run the thread: 4 5个线程，接着继续每次执行5个

################################################################################
事件event
python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 set、wait、clear。

事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。

clear：将“Flag”设置为False
set：  将“Flag”设置为True
import threading
 
def do(event):
    print 'start'
    event.wait()
    print 'execute'
 
 
event_obj = threading.Event()
for i in range(10):
    t = threading.Thread(target=do, args=(event_obj,))
    t.start()
 
event_obj.clear()
inp = raw_input('input:')
if inp == 'true':
    event_obj.set()
#开始时会先输出10个'start'，然后等待，当设置事件Flag为true时，就会继续执行10个'execute'
####################################################################################
函数外定义的变量如果要在函数内部使用的话，需要使用global进行声明
python的连接符是'+'号，但是连接的两边都必须是字符串，如果是数字则需要用str函数转义
######################################################################################
条件（Condition）

使得线程等待，只有满足某条件时，才释放n个线程
生产者消费者模型
import time
import threading
 
#当还剩下一百个产品时，则不进行消费，待生产者生产
#当生产了一千个产品时，则不进行生产，待消费者消费
 
product = 0 #产品初始化时为0
 
lock = threading.Condition()
 
class Producer(threading.Thread):
    def __init__(self, lock):
        self._lock = lock
        threading.Thread.__init__(self)
 
    def run(self):
        global product
        while True:
            if self._lock.acquire():      #acquire一个条件变量，然后开始判断一些条件，条件不满足则wait
                if product >= 1000:
                    self._lock.wait()     #条件满足，处于阻塞状态
                else:
                    product += 100
                    print "add 100, product count=" + str(product)
                    self._lock.notify()   #小于1000时，通知其他线程，其他处于wait状态的线程接到通知后会重新判断条件，不断的重复这一过程，从而解决复杂的同步问题
                self._lock.release()      #释放锁
                time.sleep(1)
 
class Consumer(threading.Thread):
    def __init__(self, lock):
        self._lock = lock
        threading.Thread.__init__(self)
 
    def run(self):
        global product
        while True:
            if self._lock.acquire():
                if product <= 100:
                    self._lock.wait()
                else:
                    product -= 3
                    print 'consum 3, count=' + str(product)
                    self._lock.notify()
                self._lock.release()
                time.sleep(1)
 
 
def test():
    for i in range(5):
        p = Producer(lock)
        p.start()
 
    for i in range(5):
        s = Consumer(lock)
        s.start()
 
if __name__ == '__main__':
    test()
###########################################################################################
Timer定时器，指定n秒后执行某操作
from threading import Timer

def Hello():
        print 'Hello world'

t=Timer(5,Hello)   #5S后执行该函数
t.start()
###########################################################################################
进程
from multiprocessing import Process
  
def foo(i):
    print 'say hi',i
  
for i in range(10):
    p = Process(target=foo,args=(i,))
    p.start()
进程相当于是又重新复制了一份和父进程完全一模一样的，而且是数据各自持有一份，所以需要的内存开销比较大
进程数据实现共享：
#方法一，Array
from multiprocessing import Process,Array
temp = Array('i', [11,22,33,44])   #此数组可以循环,i代表类型
 
def Foo(i):
    temp[i] = 100+i
    for item in temp:
        print i,'----->',item
 
for i in range(2):
    p = Process(target=Foo,args=(i,))    #开启了两个线程,每个进程执行顺序是不固定的，但是输出是一样的
    p.start()
输出结果：
0 -----> 100
0 -----> 101
0 -----> 33
0 -----> 44
1 -----> 11
1 -----> 101
1 -----> 33
1 -----> 44
或
1 -----> 11
1 -----> 101
1 -----> 33
1 -----> 44
0 -----> 100
0 -----> 101
0 -----> 33
0 -----> 44
类型大全：
*****************************************
'c': ctypes.c_char,  'u': ctypes.c_wchar,
'b': ctypes.c_byte,  'B': ctypes.c_ubyte,
'h': ctypes.c_short, 'H': ctypes.c_ushort,
'i': ctypes.c_int,   'I': ctypes.c_uint,
'l': ctypes.c_long,  'L': ctypes.c_ulong,
'f': ctypes.c_float, 'd': ctypes.c_double
******************************************

#方法二：manage.dict()共享数据
from multiprocessing import Process,Manager

manage = Manager()
dic = manage.dict()
 
def Foo(i):
    dic[i] = 100+i
    print dic.values()
 
for i in range(2):
    p = Process(target=Foo,args=(i,))
    p.start()
    p.join()           #这个不能少
输出：
[100]
[100, 101]

#########################################################
进程加锁：
from multiprocessing import Process, Array, RLock

def Foo(lock,temp,i):
    lock.acquire()
    temp[0] = 100+i
    for item in temp:
        print i,'----->',item
    lock.release()

lock = RLock()
temp = Array('i', [11, 22, 33, 44])

for i in range(20):
    p = Process(target=Foo,args=(lock,temp,i,))
    p.start()
############################################################
进程池：
Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程。

import multiprocessing
import time

def func(msg):
    print "msg:", msg
    time.sleep(1)

if __name__ == "__main__":
    pool = multiprocessing.Pool(processes = 3)
    for i in xrange(4):
        msg = "hello %d" %(i)
        pool.apply_async(func, (msg, ))   #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去

    pool.close()  #关闭pool，不再接受新的任务
    pool.join()   #调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束

进程池只有3个进程，所以当需要同时执行4次时，会有一个需要其他进程执行完毕后才会执行
输出：
hello 1
hello 2
hello 3
此处等待1S
hello 4
-----------------------------
import multiprocessing
import time

def func(msg):
    print "msg:", msg
    time.sleep(1)

if __name__ == "__main__":
    pool = multiprocessing.Pool(processes = 3)
    for i in xrange(4):
        msg = "hello %d" %(i)
        pool.apply(func, (msg, ))   #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去

    pool.close()
    pool.join()
#输出结果（每隔1S执行1个）：
msg: hello 0
msg: hello 1
msg: hello 2
msg: hello 3
#############################################################################
apply_async(func[, args[, kwds[, callback]]]) 它是非阻塞，主函数和主进程互不干扰
apply(func[, args[, kwds]])是阻塞的，会先执行主函数，在执行主进程
close():关闭pool，不再接受新的任务
terminate():结束工作进程，不再处理未完成的任务
join():主进程阻塞，等待子进程的退出，join()方法要在close和terminate后
multiprocessing.cpu_count()  #获取cpu的个数

使用进程池并关注结果
import multiprocessing
import time

def func(msg):
    print "msg:", msg
    time.sleep(1)
    return "done" + msg

if __name__ == "__main__":
    pool = multiprocessing.Pool(processes=4)
    result = []
    for i in xrange(3):
        msg = "hello %d" %(i)
        result.append(pool.apply_async(func, (msg, )))
    pool.close()
    pool.join()
    for res in result:
        print res.get()   #获取结果
    print "Sub-process(es) done.
返回结果：
msg: hello 0
msg: hello 1
msg: hello 2
等待1s
donehello 0
donehello 1
donehello 2
Sub-process(es) done
######################################################################
from  multiprocessing import Process,Pool
import time
  
def Foo(i):
    time.sleep(2)
    return i+100
  
def Bar(arg):
    print arg
  
pool = Pool(5)
  
for i in range(10):
    pool.apply_async(func=Foo, args=(i,),callback=Bar)    #Foo返回的结果作为Bar函数的参数
  
print 'end'
pool.close()
pool.join()#进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。
#########################################################################
协程：
线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。

协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。

协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程；

from greenlet import greenlet
 
 
def test1():
    print 12
    gr2.switch()   #切换到test2
    print 34
    gr2.switch()
 
 
def test2():
    print 56
    gr1.switch()
    print 78
 
gr1 = greenlet(test1)
gr2 = greenlet(test2)
gr1.switch()          #开始先执行

#线程池
import Queue
import threading
import time

class ThreadPool(object):

        def __init__(self,max_num=20):
                self.queue=Queue.Queue(max_num)
                for i in xrange(max_num):
                        #只创建一个类，在内存空间里
                        self.queue.put(threading.Thread)

        def get_thread(self):
                return self.queue.get()

        def add_thread(self):
                return self.queue.put(threading.Thread)

pool=ThreadPool(10)

def func(arg,p):
        print arg
        time.sleep(1)
        p.add_thread()

for i in xrange(30):
        thread=pool.get_thread()
        t=thread(target=func,args=(i,pool))
        t.start()
或者：
self.queue.put(threading.Thread)改成self.queue.put(1)
t=threading.Thread(target=func,args=(i,pool))
利用上下文统计活跃线程的个数：
import time
import contextlib   #上下文切换的模块
import threading
doing=[]

def count(l2):
        while True:
                print len(l2)
                time.sleep(1)
t=threading.Thread(target=count,args=(doing,))
t.start()

@contextlib.contextmanager
def show(l1,item):
        doing.append(item)
        #在这里冻结,执行完with里面的函数之后接着来执行下面的
        yield
        doing.remove(item)

def task():
        with show(doing,1):
                print 'with in'
                time.sleep(10)   #这里暂停10s，就可以统计10个线程活跃的个数，不设置的话，统计不到

for i in range(20):
        t1=threading.Thread(target=task)
        t1.start()

threadpool模块：
import threadpool
import time

def say(arg):
        print 'arg: ',arg

pool=threadpool.ThreadPool(5)
requests=threadpool.makeRequests(say,range(10))   #第二个参数是数组，第三个参数是回调函数，以函数的返回值作为参数
for req in requests:
        pool.putRequest(req)
pool.wait()

#MySQLdb
recount=cur.execute(select * from tb)
1,alex
2,cash
3,tom
4,jack
print cur.fetchone()   //alex
cur.scroll(0,mode='absolute')   //绝对位置的移动,又回到原来的位置alex
print cur.fetchone()   //alex
print cur.fetchone()   //cash
cur.scroll(1,mode='relative')   //正值向下移动N个位置，此时得到的值是jack
cur.scroll(-3,mode='relative')  //负值向上移动N个位置,此时得到的值是alex